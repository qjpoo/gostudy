package main

import "fmt"

func f1(s string)  {
	fmt.Println(s)

}

func f2(x int) {
	fmt.Println(x)  // 100
}
func main() {
	// defer 延迟执行
	// defer函数时，函数并不会执行，只是触发了函数，里面的语句都不执行，但是参数还是会传递
	/*
	defer 特点：
	1. 有栈的特点，先进后出
	2. defer 函数在调用的时候，就已经传递了参数数据，只是暂时不执行函数里面的代码，等外围函数都执行完了，在执行defer里面的代码
	3. 当外围函数中的语句正常执行完毕，只有其中所有的延迟函数都执行完毕了，外围函数才会真正的结束执行
	4. 当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完，外围函数才会真正的返回
	*/

	defer f1("我被延迟执行了 0000000000000000000000") // 外围函数所有的步骤都执行完成之后，在执行这个代码  先进入，后执行
	f1("11111111111111")
	defer f1("我被延迟执行了 2222222222222222") // 外围函数所有的步骤都执行完成之后，在执行这个代码
	f1("33333333333333333")
	fmt.Println("44444444444444444")


	e := 100
	defer f2(e)
	e++
	fmt.Println(e) // 101


	fmt.Println("1------------------------------")
	return
	fmt.Println("2------------------------------")


}
