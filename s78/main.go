package main

import "fmt"

func main() {
	// 闭包
	/*
	go语言支持函数式的编程:
	1. 支持将一个函数作为另一个函数的参数
	2. 也支持将一个函数作为另一个函数的返回值

	只要记住函数是特殊的变量, 引用传递, 函数本身就是存储地址的

	将一个函数作为另一个函数的返回值就是闭包  closurek

	闭包导致变量逃逸

	一个外层函数中,有内层函数,该内层函数中,会操作外层函数的局部变量(外层的参数,或者外层直接定义的变量)
	并且该外层函数的返回值就是这个内层函数,这个内层函数和外层函数的局部变量,统称为闭包结构

	这个局部变量的生命周期会发生改变,正常的局部变量随着函数的调用而创建,随着函数的结束而销毁
	但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁,因为内层函数还要继续的使用




	*/

	ret1 := f1()  // ret1 = 里面的内层函数
	fmt.Printf("%T\n", ret1)
	fmt.Println(ret1)  // int0x49fc20
	fmt.Println(ret1())  // 1
	fmt.Println(ret1())  // 2

	ret2 :=f1()
	fmt.Println(ret2())  // 1
	fmt.Println(ret2())  // 2

	fmt.Println(ret1())  // 3


}
func f1() func() int {  // 外层函数
	// 定义了一个局部变量
	i := 0
	// 返回匿名函数
	return func() int{  // 内层函数  这里只是定义了,并没有执行,因为没有()
		i++
		return i
	}

}